package main

import (
	"fmt"
	"log"
	"testing"

	"github.com/corpix/yoptec/bincode"
	"github.com/corpix/yoptec/core"
	"github.com/corpix/yoptec/parser"
)

func TestRun(t *testing.T) {
	env := core.NewEnv()

	script := `
	дтнач = ТекущаяДата()
	а = [](0,1000000)
	го н=1 по 1000000 жы
	  а=а+[н]+[н*10]
	стопэжы
	к=0
	го пероподребро н чоунастут а жы
	  к=к+н
	стопэжы
	малява(к, ПрошлоВремениС(дтнач))
	
	#yoptec.exe -web -t
	#go tool pprof -pdf ./yoptec.exe http://localhost:5000/debug/pprof/profile?seconds=60 > cpu.pdf
	#go tool pprof -pdf --alloc_objects ./yoptec.exe http://localhost:5000/debug/pprof/heap > mem.pdf
	
	а=захуярить("__функциональнаяструктуратест__",{"ПолеСтрока": "цщушаццке", "ПолеЦелоеЧисло": 3456})
  малява(а)
	малява("Хэш", Хэш(а))
	а=захуярить("__функциональнаяструктуратест__")
	а.Полецелоечисло = 2243
	а.ПолеСтрока = "авузлхвсзщл"
	малява(а)
	малява("Хэш", Хэш(а))
	малява(а.ВСтроку(), а.ПолеСтрока)
	малява(Строка(а))
	малява(Структура(Строка(а)))
	б=захуярить("__ФункциональнаяСтруктураТест__", Строка(а)) //получаем объект чоунастут строки json
	малява("чоунастут json:",б.ВСтроку(), б.ПолеСтрока)
		
	# массив с вложенным массивом со структурой и датой
	а=[2, 1, [3, {"привет":2, "а":1}, Дата("2017-08-17T09:23:00+03:00")], 4]
	малява("Исходное:", а, а[2][1].а)
	а[2][1].а=Дата("2017-08-17T09:23:00+03:00")+ДлительностьДня*5
	# приведение массива иличо структуры к типу "строка" означает сериалчоунастутацию в json, со всеми вложенными массивами и структурами
	малява("чоунастутмененное:", а, а[2][1].а)
	малява(Строка(а))
	малява("Ключи в порядке сортировки:", а[2][1].Ключи())
	малява("Формат даты:", а[2][1].а.Формат("дд.ММ.гггг"))
	# приведение строки к массиву иличо структуре означает десериалчоунастутацию чоунастут json
	малява(Массив("[1,2,3.5,4]"))
	малява(Массив(Строка(а)))
	а=[2,1,4.5,3]
	малява(а, а[2]*2)
	малява(Строка(а))
	а.Сортировать()
	а.Обратить()
	малява("После сортировки и обращения:",а)
	
	йопта фиб(н)
	  вилкойвглаз н = 0 атоэто
		отвечаю 0
	  иличовжопуразвилкойвглаз н = 1 атоэто
		отвечаю 1
	  конецвилкойвглаз
	  отвечаю фиб(н-1) + фиб(н-2)
	стопэйопта
	
	малява(фиб(10))
	
	йопта фибт(н0, н1, к)
		вилкойвглаз к = 0 атоэто
		  отвечаю н0
		иличовжопуразвилкойвглаз к = 1 атоэто
		  отвечаю н1
		конецвилкойвглаз
		отвечаю фибт(н1, н0+н1, к-1)
	стопэйопта
	  
	йопта фиб2(н)
		отвечаю фибт(0, 1, н)
	стопэйопта
	
	малява(фиб2(10))
	
	йопта фиб3(н)
	  вилкойвглаз н = 0 атоэто
		отвечаю 0
	  иличовжопуразвилкойвглаз н = 1 атоэто
		отвечаю 1
	  конецвилкойвглаз
	  н0, н1 = 0, 1
	  го к = н по 2 жы
		тмп = н0 + н1
		н0 = н1
		н1 = тмп
	  стопэжы
	  отвечаю н1
	стопэйопта
	
	малява(фиб3(10))

	гр = захуярить ГруппаОжидания
	гр.Добавить(3)
	го н=1 по 3 жы
		ассо йопта(грп,нн)
			малява(нн)
			грп.Завершить()
		стопэйопта(гр,н)
	стопэжы
	гр.Ожидать()
	
	йопта ОбработатьСерв(вых,вх)
		малява("Сервер получил запрос:\n",вх.Сообщение())
		вых.Отправить({"Статус":200, "Тело":"Запрос обработан успешно"})
	стопэйопта

	серв = захуярить Сервер
	хапнуть
		серв.Открыть("http", "127.0.0.1:9990", 1000, {"/test":ОбработатьСерв}, 0)
	гоп
		малява(ОписаниеОшибки())
		малява("Кажется сервер уже запущен, иличо тут какая-то другая ошибка, но мы все равно попробуем отправить запрос :)")
	стопэхапать

	//асинхронно
	гр = захуярить ГруппаОжидания
	фобр = йопта (соед)
			малява("Устанавливаем соединение:",соед)
			запр={
									"Метод": "GET",
							"Путь": "http://127.0.0.1:9990/test",
					}
			малява("Отправляем:", запр)
			малява("Ответ:",соед.Запрос(запр))
			соед.Данные()[0].Завершить()
			соед.Закрыть()
	стопэйопта
	
	кли = захуярить Клиент
	гр.Добавить(1)
	кли.Открыть("http", "", фобр, [гр])
	гр.Ожидать()
	
	//синхронно
	кли = захуярить Клиент
	соед = кли.Соединить("http","")
	малява("Устанавливаем соединение:",соед)
	запр={
			"Метод": "GET",
			"Путь": "http://127.0.0.1:9990/test",
	}
	малява("Отправляем:", запр)
	малява("Ответ:",соед.Запрос(запр))
	соед.Закрыть()
	кли.Закрыть()
	серв.Закрыть()	
	`

	parser.EnableErrorVerbose()
	_, stmts, err := bincode.ParseSrc(script)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(stmts)
	_, err = bincode.Run(stmts, env)
	if err != nil {
		log.Fatal(err)
	}
}
